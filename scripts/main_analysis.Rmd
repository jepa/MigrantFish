---
title: "Untitled"
author: "Juliano Palacios-Abrantes"
date: '2022-04-20'
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}

library(MyFunctions)

packages <- c(
  "readxl", # Read dataframe
  "data.table", # Read dataframe (Fast!)
  "wesanderson",
  "tidyverse", # for all data wrangling and ggplot
  "janitor", # for data cleaning
  "tidytext", # to order the facet wrap https://juliasilge.com/blog/reorder-within/
  "cowplot", # for figures 1 and 3
  # "ggimage", #for reading images to the circular plot
  "ggrepel", # for nice plot labels
  # "ggsflabel", # for nice sf_plots labels
  # "spdep", # for poly2nb old
  "sf", #Spatial analysis 
  "sp", #Spatial analysis 
  # "purrr",#Spatial analysis
  # "rgdal", #Spatial analysis
  "tools", #Spatial analysis 
  "parallel", # for parallelization
  "doParallel", # for parallelization
  # "taxize", # For getting species names
  "rfishbase", # for species ecosystem affinity
  "zoo", #for runing mean
  # "pgirmess", # for dune test after kurtis wallas
  "rnaturalearth", # For maps
  "R.matlab", # For Gabs distributions
  "parallel",
  "viridis",
  # Juanitos map
  "zeallot",
  "geosphere",
  # Sankey network
  "networkD3",
  "circlize"
)

my_lib(packages)

# Fix new updates of sf package
sf::sf_use_s2(use_s2 = FALSE)
```


# Methods

1.- Get transboundary species list

1.1- Remove highly migratory species based on literature

2- High seas shapefile

2.1- FAO Areas ID

3.- Identiy what transboundary species are actually straddling 

4.- Be happy, happy like a hippo

# Data

## Shapefiles 

```{r shapefiles, eval = F}

# World land maps
world_land <- ne_countries(scale = 'medium', returnclass = c("sf")) %>% 
  st_transform(crs = 4326)# 4326

# Coordinatres DBEM
coords_dbem <- my_path("Spa","DBEM","Lon_Lat_DBEM.txt",read = T, header = F)
colnames(coords_dbem) <- c("index","lon","lat")

dbem_sf <-st_as_sf(coords_dbem,
                   coords = c("lon", "lat")
) %>% 
  st_set_crs(4326) #%>%
# st_transform(crs = "+proj=eck4")

st_crs(dbem_sf) = 4326

# EEZs
# world_eez <- my_sf("SAU",simple = 1000)

# SAU index table
sau_index_code <- my_data("sau_index")

### Get MEO to DBEM

meow_regions <- my_sf("MEOW")
st_crs(meow_regions) = 4326

meow_dbem <- st_join(dbem_sf,
                     meow_regions,
                     join = st_intersects)


# Get eez per realm
dbem_meow_df <- meow_dbem %>% 
  as.data.frame() %>% 
  select(-geometry) %>% 
  clean_names() %>% 
  filter(!is.na(realm))


# dbem_meow_df %>%
#   left_join(coords_dbem) %>%
#   ggplot() +
#   geom_tile(
#     aes(
#       x = lon,
#       y = lat,
#       fill = realm
#     )
#   )


# RFMO regions
# RFMO data
sf_rfmo <- my_sf("RFMO") %>% 
  filter(RFMO_nm_s %in% c("ICCAT","WCPFC","IOTC","IATTC","CCSBT")) %>% 
  dplyr::rename(rfmo_name = RFMO_nm_s) %>% 
  group_by(rfmo_name) %>% 
  summarise(geometry = st_union(geometry))

st_crs(sf_rfmo) = 4326

rfmo_dbem <- st_join(dbem_sf,
                     sf_rfmo,
                     join = st_intersects)

# Select only high seas (i.e., remove waters within EEZs)
rfmo_dbem_hs <- rfmo_dbem %>% 
  as.data.frame()%>% 
  select(-geometry) %>% 
  clean_names() %>% 
  filter(!is.na(rfmo_name)) # remove areas where no tuna RFMO exists (some high seas pockets)


# Finalize data
dbem_rfmo_index <- rfmo_dbem_hs %>% 
  filter(!index %in% dbem_meow_df$index)
  

# dbem_rfmo_index %>%
#   left_join(coords_dbem) %>%
#   ggplot() +
#   geom_tile(
#     aes(
#       x = lon,
#       y = lat,
#       fill = rfmo_name
#     )
#   ) +
#   geom_tile(data = dbem_meow_df %>% left_join(coords_dbem),
#     aes(
#       x = lon,
#       y = lat
#     ),
#     fill = "red"
#   )

write_csv(dbem_rfmo_index, my_path("Spa", "SAU/SAU_RFMO/","RFMO_Index_Code.csv"))





## Coombine rfmo and MEOW shapefiles in one


sf_rfmo_to_combine <- sf_rfmo %>% 
  select(region = rfmo_name, geometry)

sf_meow_to_combine <- meow_regions %>% 
  select(region = REALM, geometry)
  
sf_meow_rfmo <- rbind(sf_rfmo_to_combine, 
                      sf_meow_to_combine)




```

## Determine adjacent RFMOs and MEOWS

Code modified from FishForVisa

```{r funEstNeighbours, eval = F, echo=T}

Shapefile = sf_meow_rfmo

  # Get sparse matrix
int = suppressMessages(st_intersects(Shapefile))
  # Warnning message
  # although coordinates are longitude/latitude, st_intersects assumes that they are planar
  
  
  # Intitalize new object
  mat = NULL
  
  # Fill
  for(i in 1:NROW(int)){
    #Create matrix with ID and intersecting IDs
    tmp = cbind(i, int[[i]])
    
    # Join to Initalized object
    mat  = rbind(mat, tmp)
  }
  
  # Build final data.frame substituting ID for name (in this case nc$name)
  Result_table = data.frame(region = Shapefile$region[mat[,1]], 
                            adjacent_region = Shapefile$region[mat[,2]]
                            )
  
  # Remove duplicates... eg of course an object intersects with itself...
  Result_table = Result_table[Result_table$region != Result_table$adjacent_region,]
  
 # Get index cells within those RFMOs
  rfmo_partial <- Result_table %>% 
        rename(rfmo_name = region) %>% 
    left_join(rfmo_dbem, 
                  by = "rfmo_name")%>% 
    filter(!is.na(index)) %>% 
    rename(region = rfmo_name)
  
  # Get index cells within those MEOWS
  meow_partial <- Result_table %>% 
        rename(realm = region) %>% 
    left_join(meow_dbem_grid, 
                  by = "realm") %>% 
    filter(!is.na(index)) %>% 
    rename(region = realm)
  
  rfmo_meow_final <- bind_rows(rfmo_partial,meow_partial) %>% 
    group_by(region,adjacent_region) %>% 
    tally() %>% 
    select(-n)
  
  
  write_csv(rfmo_meow_final, my_path("G","Spatial/SAU/SAU_RFMO/","rfmo_meow_neighbours.csv"))
  
  
  
```

## Determining straddling stocks

```{r GetSppDistFun, eval = F}

# Spp = 600069
Data_Path <- my_path("G","FishForVisa")


GetSppDist=function(Spp,Model,Coord){
  
  Distpath <- paste(Data_Path,"Data/Distribution/",sep="")
  INDEX = seq(1,259200,1)
  # INDEX <- Coordinates$INDEX
  
  # SAU Distributions
  if(Model == "SAU_D"){
    File_Name <- paste("SAU_Distribution/DIST_GOOD_SP_")
  }
  
  # SAU Catch
  if(Model == "SAU_C"){
    File_Name <- paste("SAU_data_per_species/CATCH_SP_")
  }
  
  # Occurence
  if(Model == "Occ"){
    File_Name <- paste("Occurence/OCCURENCE_JULIANO_")
  }
  
  # ENM Model
  if(Model == "ENM"){
    File_Name <- paste("ENM/ENM_JULIANO_")
  }
  
  # DBEM Data
  # if(Model == "DBEM"){
  #   Distpath <- "/Volumes/DATA/JULIANO_NEYMAR/PristineSeasData
  #   Final_Path <- "ENM"
  #   File_Name <- paste("ENM_JULIANO",Spp,".mat",sep="")
  # }
  
  if(Model == "All"){
    
    Models_List <- c(paste(Distpath,"SAU_Distribution/DIST_GOOD_SP_",Spp,".mat",sep =""),
                     paste(Distpath,"Occurence/OCCURENCE_JULIANO_",Spp,".mat",sep=""),
                     paste(Distpath,"ENM/ENM_JULIANO_",Spp,".mat",sep="")
    )
    
    # Jumps species not modeled. NOTE: We only need one as ENM, Occ and SAU Dis have all the same 939 spp
    if(file.exists(Models_List[1])){
      
      Load <- lapply(Models_List, FUN=R.matlab::readMat, na.strings=0)
      
      sppdist <- as.data.frame(bind_cols(Load)) %>% 
        mutate(
          INDEX = INDEX,
          TaxonKey = Spp
        )
      colnames(sppdist) <- c("SAU_D","Occ","ENM","INDEX","TaxonKey")
      
      #### Step for SAU catch data that has to be averaged
      File_Name <- paste("SAU_data_per_species/CATCH_SP_")
      SppPath <- paste(Distpath,File_Name,Spp,".mat",sep="")
      
      # For now we're using only the last 10 years average, basicaaly if the species has been fished in any of these years, its considered present
      SAU_C_data <- as.data.frame(R.matlab::readMat(SppPath)) %>% 
        select(CATCH.1:CATCH.65) %>% 
        mutate(INDEX = INDEX) %>% 
        gather("Year","Catch",CATCH.56:CATCH.65) %>% # Last 10 years of data
        group_by(INDEX) %>% 
        summarise(SAU_C = mean(Catch,na.rm=T))
      
      # Join both tables
      sppdist <- sppdist %>% 
        left_join(SAU_C_data,
                  by = "INDEX") %>% 
        select(TaxonKey,INDEX,everything()) %>% 
        left_join(CoorG,
                  by = "INDEX")
      
      # Fix coordinate system incompatibility between Gab and DBEM
      sppdist <- suppressWarnings(sppdist[order(sppdist$latitude, rev(sppdist$longitude),decreasing=TRUE), ] %>% 
                                    mutate(INDEX = seq(1,259200,1)) %>% 
                                    gather("Model","Value",3:6) %>%
                                    mutate(Value = ifelse(is.na(Value), 0, Value)) # Converting NA's to ceros
      )
      
      getSppDist = sppdist
      
    }
    
  }else{  
    
    # Merge paths
    SppPath <- paste(Distpath,File_Name,Spp,".mat",sep="")
    
    if(file.exists(SppPath) == TRUE){
      
      #Install (if needed) R.matlab package
      if(!require(R.matlab)){
        install.packages("R.matlab")
      }
      
      # Read Files
      
      sppdist <- as.data.frame(R.matlab::readMat(SppPath)) %>% 
        mutate(INDEX = INDEX,
               Species = Spp) %>% 
        left_join(Coord) 
      
      # Fix coordinate system incompatibility between Gab and DBEM
      sppdist <- sppdist[order(sppdist$latitude, rev(sppdist$longitude),decreasing=TRUE), ] %>% 
        mutate(INDEX = seq(1,259200,1))
      
      # Return 
      getSppDist=sppdist
      
    }else{
      print(paste("No info for this species",Spp, "in",Model))
    }
    
  }
}
```

```{r StraddIndexFun, eval = F}

StraddIndex <- function(Spp, Model = "All", Neighbours, Coord, Index_Code){
  
  # Get model data from spps
  SppDist <- GetSppDist(Spp,Model,Coord)
  
  # Result 1. Number of Countries that share the species
  
  #____________ ESTIMATING MODEL INDEX (TRESHOLD 1)_________ #
  Trans_Spp <- SppDist %>%
    filter(Model != "SAU_C") %>% 
    mutate(Value = ifelse(Value > 0, 1,0)) %>%  
    group_by(TaxonKey, INDEX) %>%
    summarise(Model_Index = sum(Value,na.rm=T)/3,
              .groups = "drop") %>%
    filter(Model_Index > 0.4) %>% # at least 2 sources agree
    # ____________ ESTIMATING FUNDAMENTAL NICHE (TRESHOLD 2)_________ #
    left_join(SppDist,
              by = c("TaxonKey","INDEX")) %>%
    filter(Model == "SAU_C", # Only keeping cells where SAU catch exists
           Value > 0) %>%
    mutate(Model_Index = Model_Index*100) %>%
    select(-Model, -Value, -latitude,-longitude) %>%
    rename(index = INDEX) %>% 
    # joint eez names
    left_join(meow_dbem_grid, # No EEZs but MEOWs
              by = "index") %>% 
    # joint rfmo area names
    left_join(rfmo_index,
              by = "index") %>% 
    mutate(
      region = ifelse(is.na(rfmo_name),realm,rfmo_name),
      category = ifelse(!is.na(rfmo_name),"rfmo","realm"),
    ) %>%
    select(1:3,region,category) %>% 
    clean_names() %>% 
    filter(model_index == 100)
  
  ### ----------  Distributional test  ---------- ###
  # test <- Trans_Spp %>%
  # left_join(coords_dbem) #%>% 
  # filter(is.na(territory))
  
  # sau_index_code %>% filter(eez_name != "High seas") %>% 
  #   left_join(coords_dbem) %>% 
  #   ggplot() +
  #   geom_tile(
  #     aes(
  #       x = lon,
  #       y = lat
  #     ),
  #     fill = "red"
  #   ) + 
  #   geom_tile(data = meow_dbem_grid %>% left_join(coords_dbem),
  #     aes(
  #       x = lon,
  #       y = lat,
  #       # fill = rfmo_name
  #     ),
  #     fill = "black"
  #   ) + 
  #   geom_sf(data = sf_land, aes())
  
  # 
  # ggplot(test) +
  #   geom_tile(
  #     aes(
  #       x = lon,
  #       y = lat,
  #       fill = territory
  #     )
  #   ) +
  #   geom_sf(data = sf_land, aes())
  
  
  ### ----------------------------------- ###
  
  # Get realms and RFMOs
  rfmo_to_realm <- Neighbours %>% 
    filter(region %in% c(Trans_Spp %>% filter(category == "rfmo") %>% pull(region) %>% unique()),
           adjacent_region %in% c(Trans_Spp %>% filter(category == "realm") %>% pull(region) %>% unique()))
  
  
  # Model treshold
  Model_Index_D<- Trans_Spp %>% 
    filter(region %in% rfmo_to_realm$region) %>% 
    left_join(rfmo_to_realm,
              by = "region",
              relationship = "many-to-many") %>%
    group_by(region,
             adjacent_region,
             category,
             taxon_key,
             model_index
    ) %>% 
    summarise(n_cells_spp = n(),
              .groups = "drop") %>% 
    select(-n_cells_spp)
  
  
  
  #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
  # The number of species' cells present within each REALM and RFMO
  
  Spp_Grid <- Trans_Spp %>% 
    group_by(taxon_key,
             model_index, 
             region,
             category) %>% 
    summarise(n_cells_territory = length(unique(index)),
              .groups = "drop")
  
  # Split dataframes to merge latter
  Territory_T <- Spp_Grid %>% 
    filter(category == "realm") %>% 
    ungroup() %>% 
    select(
      model_index, # Un-comment after producing models x datasets
      taxon_key,
      Name=region,
      n_cells_territory
    )
  
  Neighbour_T <- Spp_Grid %>%
    filter(category == "rfmo") %>% 
    ungroup() %>% 
    select(
      model_index,
      taxon_key,
      n_cells_territory,
      Name=region
    ) 
  
  
  rfmo_grid <- Spp_Grid %>% 
    filter(category == "rfmo") %>% 
    left_join(rfmo_to_realm,
              by = "region") %>% 
    select(Name =adjacent_region,
           rfmo_name = region,
           n_cells_territory)
  
  # Merge dataframes to get totals per Neighbourds
  Area_Index_D <-
    full_join(Territory_T,
              Neighbour_T, 
              by = c("model_index","Name","taxon_key")
    ) %>%
    left_join(rfmo_grid,
              by ="Name") %>% 
    filter(!is.na(rfmo_name)) %>% # remove non-straddling stocks
    rowwise() %>%
    mutate(spp_total = sum(n_cells_territory.x,n_cells_territory,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(realm = Name,
           n_cells_realm = n_cells_territory.x,
           n_cells_rfmo = n_cells_territory) %>%
    # Estimate if it is straddling by counting the percentage of the distribution in the RFMO
    mutate(stradling_index = (n_cells_rfmo/spp_total)*100)
  
  
  output <- Area_Index_D %>% 
    select(taxon_key,
           realm,
           rfmo_name,
           stradling_index)
  
  File_Name <- paste(Spp,"_straddling.csv",sep = "")
  Save_Path <- my_path("R","Straddling_realm_rfmo", File_Name)
  
  if(nrow(output) >0){
  
  write_csv(output,
            Save_Path)
    
    return(print(paste("Completed analysis for taxon key",Spp)))
  }else{
    return(print(paste("Taxon key",Spp,"is not a straddling stock")))
  }
  
  
} # closes function

#Test me  
# suppressMessages(
#   StraddIndex(600069, Model = "All", Coord = coords, Index_Code = Index_Code)
# )

```

```{r Mclapply_Hack_Fun, eval= F , echo = T, warning = F, message = F}

# The hack

Mclapply_Hack <- function(...){
  ## Create a cluster
  size.of.list <- length(list(...)[[1]])
  
  cl <- makeCluster(min(size.of.list, n_cores))
  
  ## Find out the names of the loaded packages 
  loaded.package.names <- c(
    ## Base packages
    sessionInfo()$basePkgs,
    ## Additional packages
    names(sessionInfo()$otherPkgs))
  tryCatch( {
    
    ## Copy over all of the objects within scope to
    ## all clusters. 
    this.env <- environment()
    while( identical( this.env, globalenv() ) == FALSE ) {
      clusterExport(cl,
                    ls(all.names=TRUE, env=this.env),
                    envir=this.env)
      this.env <- parent.env(environment())
    }
    clusterExport(cl,
                  ls(all.names=TRUE, env=globalenv()),
                  envir=globalenv())
    
    ## Load the libraries on all the clusters
    ## N.B. length(cl) returns the number of clusters
    parLapply( cl, 1:length(cl), function(xx){
      lapply(loaded.package.names, function(yy) {
        require(yy , character.only=TRUE)})
    })
    
    ## Run the lapply in parallel 
    return( parLapply( cl, ...) )
  }, finally = {        
    ## Stop the cluster
    stopCluster(cl)
  })
  
  
  ## Warn the user if they are using Windows
  if( Sys.info()[['sysname']] == 'Windows' ){
    message(paste(
      "\n", 
      "   *** Microsoft Windows detected ***\n",
      "   \n",
      "   For technical reasons, the MS Windows version of mclapply()\n",
      "   is implemented as a serial function instead of a parallel\n",
      "   function.",
      "   \n\n",
      "   As a quick hack, we replace this serial version of mclapply()\n",
      "   with a wrapper to parLapply() for this R session. Please see\n\n",
      "     http://www.stat.cmu.edu/~nmv/2014/07/14/implementing-mclapply-on-windows \n\n",
      "   for details.\n\n"))
  }
  
  ## If the OS is Windows, set mclapply to the
  ## the hackish version. Otherwise, leave the
  ## definition alone. 
  mclapply <- switch( Sys.info()[['sysname']],
                      Windows = {Mclapply_Hack}, 
                      Linux   = {mclapply},
                      Darwin  = {mclapply})
  
}
## end mclapply.hack.R

```

### Control pannel

```{r control_pannel, eva = F}

# Gabriel's coordinate system 
CoorG <- my_path("G","FishForVisa/Data/Spatial/","coordinates_gab.csv",read =T) %>%
  mutate(INDEX = seq(1,259200,1))

# RFMO data
rfmo_index <- my_path("Spa","/SAU/SAU_RFMO/","RFMO_Index_Code.csv", read = T)

# DBEM to MEOW grid
meow_dbem_grid <- my_path("Spa","MEOW", "meow_dbem_grid.csv", read = T) %>% 
  clean_names()

# Neighboring RFMOs and MEOWs created in previous chunk on July 20
rfmo_meow <- my_path("G","Spatial/SAU/SAU_RFMO/","rfmo_meow_neighbours.csv", read = T)

# Load FishForVisa Results
transboundary_spp <- read_csv("https://media.githubusercontent.com/media/jepa/FishForVisa/master/Data/Results/Clean_Results_Trans.csv") %>% 
  # Set same filters as in FishForVisa
  filter(
    area_index >= 0.25,
    area_index <= 1-0.25,
    model_index >= 100
  )

# Double check we have 633 species
length(unique(transboundary_spp$taxon_key)) # 633

#Get DBEM coords 
coords_dbem <- my_data("dbem_coords")

# Species to ran
run_species <- list.files(my_path("R","Straddling_realm_rfmo"))
run_species <- str_sub(run_species,1,6)

run_me <- transboundary_spp %>% 
  filter(!taxon_key %in% run_species) %>% 
  pull(taxon_key) %>% 
  unique()


```


Methodological points to consider

- RFMOs neighbouring realms from the MEOW
- THe straddling index accounts for how much of the population is present (as a %) in the RFMO. So if it says 80%, it means that 80% of the population is present in the RFMO and 20% in the realm.
- A straddling stock is herein defined as a stock that is shared between a REALM (and its EEZs) and a RFMO.


```{r run_me, eval = F}

# lapply(run_me[1:2], StraddIndex, Model = "All", Coord = coords_dbem, Index_Code = sau_index_code, Neighbours = rfmo_meow)
# 

cl <- makeCluster(10) # total 12
# registerDoSNOW(cl)

repetitions <- length(run_me)
pb <- txtProgressBar(max = repetitions, style = 3)

progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)


foreach(i=1:repetitions,
        .combine = rbind,
        .packages = "tidyverse",
        .options.snow = opts,
        .verbose = T) %dopar% 
  StraddIndex(
    run_me[i],
    Model = "All",
    Coord = coords,
    Index_Code = sau_index_code,
    Neighbours = rfmo_meow
  )

close(pb)
stopCluster(cl)
gc()

```


## Estimating Proportion change

### Functions

This function simply reads all results of straddling stocks (see previous step)

```{r Fun_GetTransResults, eval = T}

GetResults=function(Spp,type = "strad"){
  
  if(type == "strad"){
    # Set the path for each file
    Distpath <- paste(my_path("R","Straddling_realm_rfmo/"),Spp,"_straddling.csv",sep="")
  }else{
    Distpath <- paste(my_path("R","Per_change_realm_rfmo/"),Spp,"_perchg.csv",sep="")
  }
  
  # Loads all files in a df
  Load_Data <- bind_rows(lapply(Distpath, FUN=fread))
  
  if(nrow(Load_Data)>0){
    
    return(Load_Data)
  }
}


```

This function is the main analysis estimating the proportion change above historic levels

```{r estimate_proportion, eval = F}
# 
# taxon_key <- 600069
# taxon_key <- 600088


taxon_proportion <- function(taxon_key){
  
  print(taxon_key)
  
  stradd_data <- GetResults(taxon_key)
  # category <- unique(stradd_data$cat)
  
  rfmo_areas <- stradd_data %>% 
    pull(rfmo_name) %>% 
    unique()
  
  files_path <-list.files(my_path("G","dbem/dbem_cmip6/r_data"),full.names = T)
  
  to_read <- paste0(taxon_key,"Abd.RData")
  
  for(m in 1:6){
    # m = 1
    #################################
    # List esm folders
    file_to_read <- paste0(files_path[m],"/",to_read)
    
    if(file.exists(file_to_read)){
      
      load(file_to_read)
      
      # Transform it to df--
      spp_data <- as.data.frame(sppabdfnl) %>% 
        rowid_to_column("index")
      colnames(spp_data) <- c("index",(seq(1951,2100,1)))
      rm(sppabdfnl) # remove original load
      
      
      # Get area of analysis
      taxon_rfmo_dbem_area <-stradd_data %>%
        pivot_longer(c(realm,rfmo_name)) %>% 
        pull(value) %>% 
        unique()
      
      # Get ammount abundance per region
      spp_data_area <-spp_data %>% 
        gather("year","value",`1951`:`2100`) %>%
        left_join(meow_dbem_grid,
                  by = c("index")
        ) %>% 
        left_join(rfmo_index,
                  by = "index",
                  relationship = "many-to-many") %>% 
        mutate(name = ifelse(is.na(realm),rfmo_name,realm)) %>% 
        filter(name %in% taxon_rfmo_dbem_area) %>%
        group_by(year,name) %>% 
        summarise(total_zone_abd = sum(value,na.rm = T),
                  .groups = "drop") %>% 
        mutate(taxon_key = as.integer(taxon_key))
      
      # Estimate proportions of each region
      
      # RFMO values
      rfmo_values <- spp_data_area %>% 
        filter(name %in% stradd_data$rfmo_name) %>% 
        rename(rfmo_total_zone_abd = total_zone_abd,
               rfmo_name = name) %>% 
        left_join(stradd_data,
                  by = c("rfmo_name","taxon_key"),
                  relationship = "many-to-many") %>% 
        rename(realm_name = realm)
      
      # Realms values
      realm_values <- spp_data_area %>% 
        filter(name %in% stradd_data$realm) %>% 
        rename(realm_total_zone_abd = total_zone_abd,
               realm_name = name)
      
      
      # combine both regions to estimate proportions
      spp_proportion <- left_join(rfmo_values,realm_values,
                                  by = join_by("year", "taxon_key","realm_name")
      ) %>% 
        mutate(region_total = rfmo_total_zone_abd+realm_total_zone_abd) %>% 
        mutate(per_rfmo = rfmo_total_zone_abd/region_total*100) %>%  # done with RFMO 
        filter(region_total >0) # Remove cases where there is no catch data in any area
      
      # How it looks
      # ggplot(spp_proportion) +
      #   geom_area(
      #     aes(
      #       x = as.numeric(year),
      #       y = per_rfmo,
      #       fill = realm
      #       # fill = high_mig_spa
      #     )
      #   ) +
      #   facet_wrap(~rfmo_name)
      
      
      # Estimate changes in abd proportion
      
      # Early proportions
      hs_historical_means <- spp_proportion %>% 
        filter(year <= 2014) %>%
        group_by(taxon_key,rfmo_name,realm_name) %>% 
        summarise(hs_mean = mean(per_rfmo, na.rm = T),
                  hs_sd = sd(per_rfmo, na.rm = T),
                  .groups = "drop") %>%
        mutate(top_tresh = hs_mean+2*hs_sd,
               low_tresh = hs_mean-2*hs_sd) %>% 
        select(-hs_mean,-hs_sd)
      
      # Estimate future proportions that overshoot the mean =- 2 sd
      prop_chng <- spp_proportion %>% 
        mutate(period = ifelse(year >2021 & year <2040,"ear",
                               ifelse(year > 2041 & year <2060,"mid",NA)
        )
        ) %>% 
        filter(!is.na(period)) %>% 
        group_by(taxon_key,rfmo_name,realm_name,period) %>% 
        summarise(mean = mean(per_rfmo, na.rm = T),
                  .groups = "drop") %>% 
        left_join(hs_historical_means,
                  by = c("taxon_key","rfmo_name","realm_name"),
                  relationship = "many-to-many") %>% 
        mutate(change = ifelse(mean > top_tresh,"gain",
                               ifelse(mean < low_tresh,"lost","same")
        )
        ) 
      
      
      # Incorporate rcp and esm info to data
      # str_count(files_path[m]) # 90
      
      final_data <- prop_chng %>% 
        mutate(esm = str_to_lower(str_sub(files_path[m],80,83)),
               rcp = paste0("rcp",str_sub(files_path[m],84,85)),
               esm = ifelse(esm == "mpi2","mpi", ifelse(esm == "mpi8","mpi",esm)),
               rcp = ifelse(rcp == "rcp6F","rcp26", ifelse(rcp == "rcp5F","rcp85",rcp)),
        ) %>% 
        select(taxon_key,esm,rcp,period,rfmo_name,change,realm_name,low_tresh,mean,top_tresh)
      
      if(m == 1){
        final_output <- final_data
      }else{
        final_output <- bind_rows(final_output,final_data)
      }
      
      
    } # Close models for loop
    
  }
  
  # Save file
  name_file <- my_path("R","Per_change_realm_rfmo", paste0(taxon_key,"_perchg.csv"))
  write_csv(final_output, name_file)
  return(paste("Data for",taxon_key, "saved"))
  
}

# taxon_proportion(600006)
# gc()
```

### Control pannel

```{r get_straddling, eval = F}

# Get fao areas on DBEM grid
# fao_area_grid <- my_path("Spa", "DBEM","fao_to_dbem_grid.csv", read = T) 
meow_dbem_grid <- my_path("Spa","MEOW", "meow_dbem_grid.csv", read = T) %>% 
  clean_names() %>% 
  select(index,realm)

# meow_dbem_grid %>% left_join(coords_dbem) %>% 
#   ggplot() +
#   geom_tile(
#     aes(
#       x = lon,
#       y = lat,
#       fill = realm
#     )
#   )


# RFMO data (REQUIRED)
rfmo_index <- my_path("Spa","/SAU/SAU_RFMO/","RFMO_Index_Code.csv", read = T)

# Spp list
spp_complete <- list.files(my_path("R","Straddling_realm_rfmo/"))
stradling_spp <- str_replace(spp_complete,"\\_.*","")

stradd_data <- bind_rows(
  lapply(stradling_spp,GetResults)
) %>% 
  mutate(taxon_key = as.character(taxon_key))

```


### Proportion estimate

```{r proportion_call, eval = F}


# taxon_proportion(taxon_key = 600069)



# suppressMessages(
#   lapply(stradling_spp[1:2],
#          taxon_proportion)
# )

# Parallelization


suppressMessages(
  mclapply(stradling_spp,
           taxon_proportion,
           mc.cores = detectCores()-2)
)


```

# Results

## Data needed

```{r results_data, eva; = T}

#-----------------# 
## Georeferenced ##
#-----------------# 

# SAU relations between INDEX and Country's EEZs
# sau_index_code <- my_data("sau_index")

#world land 
sf_land <- ne_countries(scale = 'large', returnclass = c("sf")) %>%
  st_transform(crs = 4326)

# meows
sf_meow <- my_sf("MEOW") %>% 
  clean_names()
st_crs(sf_meow) = 4326

# RFMO regions
sf_rfmo <- my_sf("RFMO_tuna",simple = 1)

# SAU shapefile
sf_eez <- my_sf("SAU", simple = 0.1)

# SAU index table
sau_index_code <- my_data("sau_index")

# SAU eez to fishing entity
sau_matching_names <- read.csv("~/Library/CloudStorage/OneDrive-UBC/Data/Spatial/SAU/sau_matching_names.csv") %>% 
  select(sf_eez_name,fishing_entity = sau_fishing_entity,iso_a3)







#-----------------# 
## Spp related   ##
#-----------------# 

# List of SAU species
exploited_spp <- my_path("G","Species", "exploited_species_list.csv", read = T)

## Straddling species ##
# Spp list
spp_complete <- list.files(my_path("R","Straddling_realm_rfmo/"))
stradling_spp <- str_replace(spp_complete,"\\_.*","")

# Get straddling stocks
shared_data <- bind_rows(
  lapply(stradling_spp,GetResults, type = "strad")
) %>% 
  left_join(exploited_spp) #%>% 
  # mutate(category = ifelse(taxon_name %in% un_species$scientific_name,"strad","high_mig"))


# Get proportion analysis
spp_complete <- list.files(my_path("R","Per_change_realm_rfmo/"))
stradling_spp <- str_replace(spp_complete,"\\_.*","")

# Get straddling stocks
prop_data <- bind_rows(
  lapply(stradling_spp,GetResults, type = "prop")
  )



#### Catch data

rfmo_list <- c(my_path("D","SAU/catch/ccsbt","SAU RFMO 3 v50-1.csv", read = F),
  my_path("D","SAU/catch/iattc", "SAU RFMO 5 v50-1.csv", read = F),
  # my_path("D","SAU/catch/iccat",),
  my_path("D","SAU/catch/iotc","SAU RFMO 7 v50-1.csv", read = F),
  my_path("D","SAU/catch/wcpfc","SAU RFMO 18 v50-1.csv")
  )


rfmo_catch <- bind_rows(
  lapply(rfmo_list, read_csv)) %>% 
  filter(scientific_name %in% unique(shared_data$taxon_name)) %>% 
  group_by(area_name,year,scientific_name,common_name,commercial_group,fishing_entity) %>% 
  #adds up gear type, fishing sectors, catch type and reporting
  summarise_at(.vars = c("tonnes","landed_value"),
               .funs = sum) %>% 
  # Average last 10 years of data
  filter(year >= 2007) %>% 
  group_by(area_name,scientific_name, common_name,commercial_group,fishing_entity) %>% 
  summarise_at(.vars = c("tonnes","landed_value"),
               .funs = mean,
               na.rm = T) %>% 
  filter(!(common_name == "Indian mackerel" & fishing_entity == "Thailand"),
         !(common_name == "Japanese anchovy" & fishing_entity == "China"),
         !(common_name == "Short mackerel" & fishing_entity == "Indonesia")
         ) #remove wrong data as per personal communication with Deng P.

```

## Straddling identification

### Straddling species map

```{r straddling_map, eval = T, echo = F}

# Scaling function for plot
scaling <- function(x,...){(x-min(x,...))/(max(x,...)-min(x,...))}

# Get MEOW and EEZs (REMOVE)
# meow_dbem_eez <- meow_dbem_grid %>% 
#   group_by(realm,eez_name) %>% 
#   tally() %>% 
#   select(-n)

# Number of straddling stocks by MEOW
strad_meow <- shared_data %>% 
  group_by(realm) %>% 
  summarise(n = length(unique(taxon_key))) %>% 
  mutate(scale_n = scaling(n))

# Number of straddling stocks by RFMO
stradd_rfmo <- shared_data %>% 
  group_by(rfmo_name) %>%
  summarise(n = length(unique(taxon_key))) %>% 
  mutate(scale_n = scaling(n))

# Number of straddling stocks by RFMO and Realm
rfmo_realm <- shared_data %>% 
  group_by(rfmo_name,realm) %>% 
  summarise(n = length(unique(taxon_key))) %>% 
  mutate(scale_n = scaling(n))

# Map it
sf_meow_map <- sf_meow %>% 
  group_by(realm) %>% 
  tally() %>% 
  select(-n)

map_rfmo_stradd <- ggplot() + 
  geom_sf(data = sf_rfmo %>% left_join(stradd_rfmo), aes(fill = n)) +
  geom_sf(data = sf_meow_map %>% left_join(strad_meow), aes(fill = n)) +
  geom_sf(data = sf_land, aes(), fill = "antiquewhite", color = "grey50") +
  scale_fill_viridis_c("Stocks\n(n)", na.value = "white",
                       limits = c(20,100)) +
  my_ggtheme_m(leg_pos = "right")

# Save plot 
ggsave("../results/figures/fig_1.png",
       map_rfmo_stradd,
       height = 5,
       width = 11
)

```


### Paper numbers on top shared species

```{r}
shared_data %>% 
  mutate(combo = paste0(realm,"_",rfmo_name)) %>% 
  group_by(common_name) %>% 
  summarise(value = length(unique(combo))) %>%
  # View()
  top_n(5,value) %>% 
  arrange(desc(value)) %>% 
  View()
```

### Straddling species circle

```{r}

Species_Data <- shared_data %>% 
  mutate(combo = paste0(realm,"_",rfmo_name)) %>% 
  group_by(group = common_name) %>% 
  summarise(value = length(unique(combo))) %>%
  top_frac(0.15,value)


label_data <- Species_Data

# Set a number of 'empty bar' to add at the end of each group
Char <- as.factor(Species_Data$group)
empty_bar <- 2
to_add <- data.frame( matrix(NA, empty_bar*nlevels(Char), ncol(Species_Data)) )
colnames(to_add) <- colnames(Species_Data)
to_add$group <- rep(levels(Char), each=empty_bar)
Species_Data <- rbind(Species_Data, to_add)
Species_Data <- Species_Data %>% arrange(group,value)
Species_Data$id <- seq(1, nrow(Species_Data))


# Get the name and the y position of each label
# Create labels for all but top 5
label_data <- Species_Data
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# prepare a data frame for base lines
base_data <- Species_Data %>% 
  group_by(group) %>% 
  summarize(start=min(id), 
            end=max(id) - empty_bar, 
            median = median(value, na.rm = T)
  ) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)),
         label = str_extract(group, '\\b[^,]+$'))


# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
# grid_data <- grid_data[-1,]
grid_data[1,2] <- 5 # Manually include bathydemerssal
grid_data[1,3] <- 1 

# Median data
median_data <- grid_data %>% 
  mutate_at(vars(start,end),
            .funs = as.numeric)

Seq_axis_spp <- seq(0,30,10)
Plot_Limit <- max(Species_Data$value,na.rm=T)
Ticks_Color <- "black"
  


# Spp_circular <- 
ggplot(Species_Data, 
       aes(x=as.factor(id), 
           y=value,
           fill=group)
) +       
  # Note that id is a factor. If x is numeric, there is some space between the first bar
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, 
               aes(x = end, y = 30, xend = start, yend = 30), 
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  geom_segment(data=grid_data,
               aes(x = end, y = 20, xend = start, yend = 20),  
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  geom_segment(data=grid_data, 
               aes(x = end, y = 10, xend = start, yend = 10),  
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  # geom_segment(data=grid_data,
  #              aes(x = end, y = 5, xend = start, yend = 5),
  #              colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  # Add median lines for each gropup
  geom_segment(data=median_data, 
               aes(x = end, y = median, xend = start+5, yend = median, colour = group),
               alpha=1, size=0.5 , inherit.aes = FALSE) +
  # Add text showing the value of each line
  annotate("text", 
           x = rep(max(Species_Data$id),4),
           y = Seq_axis_spp,
           label = Seq_axis_spp,
           color=Ticks_Color, 
           size=3, 
           angle=0, 
           fontface="bold",
           hjust=1) +
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  # Species names
  geom_text(data=label_data,
            aes(x=id, y= 30,
                label = group,
                hjust = hjust), 
            color="black",
            fontface="italic",
            alpha=1,
            size=3,
            angle= label_data$angle,
            inherit.aes = FALSE) +
  ylim(-10,105) + # sets the circle the first value the central the last value how wide
  theme_bw() +
  theme(
    # legend.position = c(1,0.11),
    # legend.position = c(0.50,0.5),
    legend.position = c(0,0),
    legend.text = element_text(size = 7),
    legend.title.align = 0.4,
    legend.title = element_text(size = 16, face = "bold"),
    legend.key = element_rect(colour = NA, fill = NA),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-3.5,4.5),"cm")
  ) +
  coord_polar() +
  scale_fill_viridis("EEZs in Realm",option="magma",discrete = T) +
  scale_color_viridis("EEZs in Realm",option="magma",discrete = T) #+
  # guides(fill=guide_legend(ncol=2))

# Save plot
# ggsave(filename = "./results/figures/species_ohi_rfmo.jpg",
#        plot = last_plot(),
#        width = 12,
#        height = 12,
#        units = "in")
```

## Catch and value

Cath and value data from the Sea Around Us as an average from 2007 to 2016

### By RFMO

```{r}

# Catch and value by RFMO
rfmo_catch %>% 
  group_by(area_name) %>% 
  summarise_at(
    .vars = c("tonnes","landed_value"),
    .funs = sum,
    na.rm = T
  ) %>% 
  mutate(
    value_billion = round(landed_value/1000000000),
    tonnes_million = round(tonnes/1000000,1)
  ) %>% 
  arrange(desc(value_billion))

```


### By commercial group

```{r}

# Catch and value by RFMO
rfmo_catch %>% 
  group_by(commercial_group) %>% 
  summarise_at(
    .vars = c("tonnes","landed_value"),
    .funs = sum,
    na.rm = T
  ) %>% 
  mutate(
    value_billion = round(landed_value/1000000000),
    tonnes_million = round(tonnes/1000000,1)
  ) %>% 
  arrange(desc(value_billion))

```

### By country

```{r}

# Catch and value by RFMO
rfmo_catch %>% 
  group_by(fishing_entity) %>% 
  summarise_at(
    .vars = c("tonnes","landed_value"),
    .funs = sum,
    na.rm = T
  ) %>% 
  mutate(
    value_billion = round(landed_value/1000000000),
    tonnes_million = round(tonnes/1000000,1)
  ) %>% 
  arrange(desc(value_billion))

```


### OHI circle map

```{r}

c_data <- rfmo_catch %>% 
  group_by(area_name,common_name) %>% 
  summarise_at(
    .vars = c("tonnes","landed_value"),
    .funs = sum,
    na.rm = T
  ) %>% 
  mutate(
    value_billion = round(landed_value/1000000000),
    tonnes_million = round(tonnes/1000000,1)
  ) %>% 
  select(
    individual = common_name,
    value = value_billion,
    group = area_name
  ) %>% 
  filter(value >0) %>% 
  arrange(group,value)



# Set a number of 'empty bar' to add at the end of each group
empty_bar <- 5
to_add <- data.frame( matrix(NA, empty_bar*length(unique(c_data$group)), ncol(c_data)) )
colnames(to_add) <- colnames(c_data)
to_add$group <- rep(unique(c_data$group), each=empty_bar)
c_data <- rbind(c_data, to_add)
c_data <- c_data %>% arrange(group)
c_data$id <- seq(1, nrow(c_data))

# Get the name and the y position of each label
label_data <- c_data
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# prepare a data frame for base lines
base_data <- c_data %>% 
  group_by(group) %>% 
  summarize(start=min(id), end=max(id) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))

# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data <- grid_data[-1,]


# The plot
ggplot(c_data %>% filter(!is.na(individual)), 
       aes(x = as.factor(id), 
                   y = value, 
                   fill = group)
       ) +       # Note that id is a factor. If x is numeric, there is some space between the first bar
  geom_bar(stat="identity", alpha=0.5) +
   # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 600, xend = start, yend = 600), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 400, xend = start, yend = 400), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 200, xend = start, yend = 200), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
    geom_segment(data=grid_data, aes(x = end, y = 0, xend = start, yend = 0), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  annotate("text", x = rep(max(c_data$id),4), 
           y = c(0, 200, 400, 600), 
           label = c("0", "200", "400", "600") ,
           color="grey", size=3 , angle=0, fontface="bold", hjust=1) +
  geom_text(data=label_data, aes(x=id, 
                                 y=value+10, 
                                 label=individual,
                                 hjust=hjust), 
            color="black", fontface="bold",alpha=0.6, size=2.5, angle= label_data$angle, inherit.aes = FALSE ) +
  ylim(-100,600) +
  # theme_minimal() +
  theme(
    legend.position = "none",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm")
  ) +
  coord_polar()

ggsave("../results/figures/circular_test.png",
       last_plot(),
       width = 7,
       height = 7)


```


### Horizontal bar plot

```{r}

rfmo_catch %>% 
  group_by(area_name,common_name) %>% 
  summarise_at(
    .vars = c("tonnes","landed_value"),
    .funs = sum,
    na.rm = T
  ) %>% 
  mutate(
    value_billion = round(landed_value/1000000000),
    tonnes_million = round(tonnes/1000000,1)
  ) %>% 
  filter(value_billion >0) %>% 
  pivot_longer(
    cols = c("value_billion","tonnes_million"),
    names_to = "variable",
    values_to = "value"
  ) %>% 
  ggplot() +
  aes(x = reorder(common_name, value),
      y = value, 
      fill = area_name)+
  geom_bar(stat="identity", alpha=0.5) +
  my_ggtheme_p(axx_tx_ang = 45,
               leg_pos = "right",
               hjust = 1) +
  facet_wrap(~variable,
             ncol = 1,
             scales = "free_y")

ggsave("../results/figures/circular_test.png",
       last_plot(),
       width = 10,
       height = 7)

```

### Economic map

```{r}
# Economics

rfmo_catch_country <- rfmo_catch %>% 
  group_by(fishing_entity,commercial_group) %>% 
  summarise_at(
    .vars = c("tonnes","landed_value"),
    .funs = sum,
    na.rm = T
  ) %>% 
  mutate(
    value_billion = round(landed_value/10000000000),
    tonnes_million = round(tonnes/1000000,1)
  ) %>% 
  left_join(sau_matching_names) %>% 
  distinct() %>% 
  group_by(iso_a3) %>% 
  summarise_at(.vars = c("tonnes_million","value_billion"),
               .funs = mean,
               na.rm = T
               )


# Make sure everyone is included
# rfmo_catch_country %>% 
#   anti_join(sf_eez,
#             by = "name") %>% 
#   View()

econ_map <- ggplot() +
  geom_sf(data = sf_land, aes(), fill = "antiquewhite", color = "grey50") +
  geom_sf(data = sf_land %>% left_join(rfmo_catch_country, by = "iso_a3"), aes(fill = value_billion))+ scale_fill_viridis_c("Value \n (USD)", na.value = "white") +
  my_ggtheme_m(leg_pos = "right")


# save legend
# legend <- cowplot::get_legend(econ_map)
# ggsave("../results/figures/legend.png", legend, width = 2, height = 2, dpi = 150)
# econ_map <- econ_map + my_ggtheme_m(leg_pos = "")


# Save plot 
ggsave("../results/figures/econ_map.png",
       econ_map,
       height = 5,
       width = 11
)


```


## Proportion change

### Proportion change map


```{r}
# A function that makes a dataframe per connection (we will use these connections to plot each lines)
data_for_connection=function( dep_lon, dep_lat, arr_lon, arr_lat, group){
  inter <- gcIntermediate(c(dep_lon, dep_lat), c(arr_lon, arr_lat), n=10, addStartEnd=TRUE, breakAtDateLine=F)             
  inter=data.frame(inter)
  inter$group=NA
  diff_of_lon=abs(dep_lon) + abs(arr_lon)
  if(diff_of_lon > 180){
    inter$group[ which(inter$lon>=0)]=paste(group, "A",sep="")
    inter$group[ which(inter$lon<0)]=paste(group, "B",sep="")
  }else{
    inter$group=group
  }
  return(inter)
}



plot_data <- prop_data %>% 
  group_by(rfmo_name,realm_name,esm,rcp,change) %>% 
  tally() %>% 
  group_by(realm_name,rfmo_name,rcp,change) %>% 
  summarise(mean_n_shifts = mean(n,na.rm = T)) %>% 
  filter(!is.na(change))


# Get FAO and MEOW centroids

rfmo_centroids <-
  as.data.frame(st_centroid(sf_rfmo)) %>% 
  ungroup() %>% 
  select(rfmo_name, geometry) %>% 
  separate(col = geometry, into = c("lon", "lat"), sep = "\\,")

# Remove "c()"
rfmo_centroids$lon <- gsub("\\(","",rfmo_centroids$lon)
rfmo_centroids$lon <- gsub("c","",rfmo_centroids$lon)
rfmo_centroids$lat <- gsub(")","",rfmo_centroids$lat)


# ggplot() +
#   geom_sf(data = sf_rfmo %>% sf_simplify, aes(), fill ="white" ) +
#   geom_sf(data = sf_land, aes(), fill = "gray30", col = "gray30") +
#   geom_text(data = rfmo_centroids, aes(x = as.numeric(lon), y = as.numeric(lat), label = rfmo_name)) +
#   geom_point(data = rfmo_centroids,
#              aes(
#                x = as.numeric(lon),
#                y = as.numeric(lat),
#                color = rfmo_name
#              )
#   )

# Get MEOW and MEOW centroids

meow_centroids <- as.data.frame(st_centroid(sf_meow)) %>% 
  ungroup() %>% 
  select(realm_name = realm, geometry) %>% 
  separate(col = geometry, into = c("lon", "lat"), sep = "\\,")

# Remove "c()"
meow_centroids$lon <- gsub("\\(","", meow_centroids$lon)
meow_centroids$lon <- gsub("c","", meow_centroids$lon)
meow_centroids$lat <- gsub(")","", meow_centroids$lat)


meow_centroids <- meow_centroids %>% 
  group_by(realm_name) %>% 
  summarise(lon = mean(as.numeric(lon)),
            lat = mean(as.numeric(lat)))

# Modify annolying points (most of them!)
meow_centroids <- meow_centroids %>% 
  mutate(
    lat = ifelse(realm_name == "Temperate Northern Atlantic",72,
               ifelse(realm_name == "Western Indo-Pacific",-9,
                      ifelse(realm_name == "Eastern Indo-Pacific",-4,
                             ifelse(realm_name == "Southern Ocean",-65,
                                    ifelse(realm_name == "Temperate South America",-55,lat
               ))))),
    lon = ifelse(realm_name == "Arctic",-55,
                 ifelse(realm_name == "Temperate Northern Pacific",-130,
                 ifelse(realm_name == "Tropical Eastern Pacific",-90,
                        ifelse(realm_name == "Eastern Indo-Pacific",95,
                               ifelse(realm_name == "Temperate South America",-60,
                                      ifelse(realm_name == "Tropical Atlantic",-55,
                                             ifelse(realm_name == "Temperate North",42,
                                                    ifelse(realm_name == "Temperate Northern Atlantic",42,
                                                           ifelse(realm_name == "Western Indo-Pacific",47,lon
                        )))))))))
  )


# ggplot() +
#   geom_sf(data = sf_meow %>% group_by(realm) %>% tally(), aes(), fill ="white" ) +
#   geom_sf(data = sf_land, aes(), fill = "gray30", col = "gray30") +
#   geom_text(data = meow_centroids, aes(x = as.numeric(lon), y = as.numeric(lat), label = name)) +
#   geom_point(data = meow_centroids,
#              aes(
#                x = as.numeric(lon),
#                y = as.numeric(lat),
#                color = name
#              )
#   ) +
#   geom_point(data = fao_centroids,
#              aes(
#                x = as.numeric(lon),
#                y = as.numeric(lat)
#              )
#   )


# Prepare data from results
Data <-
  plot_data %>% 
  # get coords for sources
  left_join(meow_centroids,
            by = "realm_name") %>%
  rename(start_lon = lon,
         start_lat = lat) %>% 
  # get coords for targets
  left_join(rfmo_centroids,
            by = "rfmo_name") %>%
  rename(
    source = rfmo_name,
    target = realm_name,
         end_lon = lon,
         end_lat = lat) %>% 
  ungroup() %>% 
  drop_na() %>% 
  mutate_at(vars(end_lon,end_lat),as.numeric)

# Get paths data
path_data <- Data 

data_ready_plot=data.frame()

for(i in c(1:nrow(path_data))){
# for(i in 1:4){
  tmp=data_for_connection(path_data$start_lon[i], path_data$start_lat[i], path_data$end_lon[i], path_data$end_lat[i] , i)
  tmp$rcp=path_data$rcp[i]
  tmp$change=path_data$change[i]
  tmp$mean_n_shifts=path_data$mean_n_shifts[i]
  tmp$source=path_data$source[i]
  tmp$objective=path_data$target[i]
  data_ready_plot=rbind(data_ready_plot,tmp)
}


sf_ready_plot <- data_ready_plot %>% 
  st_as_sf(coords = c("lon", "lat")) %>% 
  st_set_crs(4326) #%>% # to match shapefiles
# st_transform(crs = "+proj=eck4") 


# Get arrow data
arrows_data <- as.data.frame(st_coordinates(st_cast(sf_ready_plot,"POINT")$geometry)) %>% 
  bind_cols(data_ready_plot)

ggplot() +
  # geom_sf(data = sf_rfmo, aes(), fill ="white" ) +
  geom_sf(data = sf_meow %>% group_by(realm) %>% tally(), aes()) +
  geom_sf(data = sf_land, aes(), fill = "gray30", col = "gray30") +
  geom_point(data = rfmo_centroids, aes(x = as.numeric(lon), y = as.numeric(lat))) +
  geom_text(data = rfmo_centroids, aes(x = as.numeric(lon), y = as.numeric(lat), label = rfmo_name)) +
  geom_point(data = meow_centroids, aes(x = as.numeric(lon), y = as.numeric(lat))) +
  geom_text(data = meow_centroids, aes(x = as.numeric(lon), y = as.numeric(lat), label = realm_name)) +
  geom_path(data = arrows_data %>% filter(rcp == "rcp85"),
            aes(X, 
                Y,
                group = group,
                color = change,
                size = mean_n_shifts
            ),
            # size = 1,
            arrow = arrow(length = unit(0.01, "npc"),ends = "first"),
            show.legend = NA) +
  facet_wrap(~change,
             ncol =1)



```


## Sankey flow diagram

```{r}


# Prepare data
sankey_df <- prop_data %>% 
  group_by(period,esm,rcp,rfmo_name,change,realm_name) %>% 
  tally() %>% 
  group_by(period,rcp,rfmo_name,change,realm_name) %>% 
  summarise(n = round(mean(n))) %>% 
  filter(rcp == "rcp85") %>% 
  mutate(
    realm_name = str_replace(realm_name,"Southern","S."),
         realm_name = str_replace(realm_name,"Northern","N."),
         realm_name = str_replace(realm_name, "Western", "W."),
         realm_name = str_replace(realm_name,"Eastern", "E.")
  )

# Get nodes (name of zones)
nodes <- data.frame(name = c(sankey_df %>% ungroup() %>% select(node = realm_name) %>% pull(node) %>% unique(), sankey_df %>% ungroup() %>% select(node = rfmo_name)%>% pull(node) %>% unique()))


# get ids (identify each region by number)
ids <- nodes %>% 
  rowid_to_column("id") %>% 
  rename(realm_name = name) %>% 
  bind_cols(nodes) %>% 
  mutate(
    region = ifelse(name %in% sankey_df$realm_name,"realm_name","rfmo_name")
  ) %>% 
  select(id,realm_name,region)



# Create links (source and target data)
links <- sankey_df %>% 
  left_join(ids,
            by = "realm_name") %>% 
  # View()
  rename(nameb = realm_name) %>%
  rename(realm_name = rfmo_name) %>%
  left_join(ids,
            by = "realm_name") %>% 
  ungroup() %>% 
  filter(period == "mid") %>%
  select(source = id.x,
         target = id.y,
         value = n,
         change,
         everything()
  ) %>%
  mutate(source = source-1,
         target = target - 1)

# Give a color for each group:
# scales::show_col(viridis::viridis_pal(option = "plasma")(10)) # from scales package
# loss 
# same 
# gain 
# Check this for color transparency https://stackoverflow.com/questions/46616321/modify-networkd3-sankey-plot-with-user-defined-colors

 

my_color <- 'd3.scaleOrdinal() .domain(["Arctic","Central Indo-Pacific","Eastern Indo-Pacific","Southern Ocean","Temperate Australasia", "Temperate Northern Atlantic", "Temperate Northern Pacific" , "Temperate South America","Temperate Southern Africa","Tropical Atlantic","Tropical Eastern Pacific","Western Indo-Pacific","Atlantic, Northeast","Atlantic, Northwest","Pacific, Northwest", "Pacific Northeast","Indian Ocean, Eastern","Pacific, Eastern Central","Pacific, Southwest","Pacific, Western Central", "Pacific, Southeast","Indian Ocean, Antarctic","Indian Ocean, Western","Atlantic, Eastern Central","Atlantic, Western Central" ,"Atlantic, Southeast","Atlantic, Southwest"]) .range(["#F98400","#78B7C5","#0B775E"])'

# my_color <- 'd3.scaleOrdinal() .domain(["a", "b"]) .range(["#F98400","#78B7C5","#0B775E"])'


# Plot it!
sankeyNetwork(Links = links,
              Nodes = nodes,
              Source = "source",
              Target = "target",
              Value = "value", 
              NodeID = "name",
              LinkGroup = "change",
              NodeGroup = "name",
              colourScale = my_color,
              fontSize = 15, 
              nodeWidth = 20,
              sinksRight = T
)


# Paper numbers
links %>% 
  group_by(nameb,change) %>% 
  tally() %>% 
  View()


links %>% 
  group_by(nameb,change) %>% 
  summarise(sum(value)) %>% 
  View()

```



## Circle diagram

Resources:
 - https://r-charts.com/flow/chord-diagram/
 - https://www.data-to-viz.com/graph/chord.html

```{r}
library(circlize)

# Gain Data
circle_data <-
  sankey_df %>% 
  filter(period == "ear",
         change == "gain"
         # change == "lost"
         ) %>% 
  mutate(name = str_replace(realm_name," ", "\n")) %>% 
  ungroup() %>% 
  select(rowname = name,
         key = rfmo_name,
         value = n)


# Color scale for gains

# length(unique(circle_data$key)) #5
# length(unique(circle_data$rowname)) #12

# Total colors 17
mycolor_g <- c(viridis(12, alpha = 1, begin = 0, end = 1, option = "D"),
             viridis(5, alpha = 1, begin = 0, end = 1, option = "F")
             )

# png("./results/figures/circular_loss.png", width = 1300, height = 1300, res = 150, units = "px")
png("./results/figures/circular_gain.png", width = 1300, height = 1300, res = 150, units = "px")
chordDiagram(
  x = circle_data, 
  grid.col = mycolor_g,
  directional = 1, #gains
  # directional = -1, #lost
  direction.type = c("diffHeight","arrows"),
  link.arr.type = "big.arrow",
  link.sort = TRUE,
  link.largest.ontop = TRUE,
  transparency = 0.30,
  scale = F,
  symmetric = F,
  big.gap = 5
)
dev.off() 



# Gain Data
net_change <-
  sankey_df %>% 
  filter(period == "ear") %>% 
  pivot_wider(
    names_from = change,
    values_from = n) %>% 
mutate(name = str_replace(realm_name," ", "\n"),
         value = gain - lost,
       rowname_b = ifelse(value > 0,name,rfmo_name),
       key_b = ifelse(value < 0,name,rfmo_name)) %>% 
    # View()
  ungroup() %>% 
  select(rowname = rowname_b,
         key = key_b,
         value) %>% 
  filter(value != 0)

mycolor_g <- c(viridis(12, alpha = 1, begin = 0, end = 1, option = "D"),
             viridis(4, alpha = 1, begin = 0, end = 1, option = "F")
             )


png("./results/figures/circular_net.png", width = 1200, height = 1200, res = 150, units = "px")

chordDiagram(
  x = net_change, 
  grid.col = mycolor_g,
  directional = 1, 
  direction.type = c("diffHeight","arrows"),
  link.arr.type = "big.arrow",
  link.sort = F,
  link.largest.ontop = TRUE,
  transparency = 0.30,
  scale = F,
  symmetric = F
  )
dev.off() 


```


### As proportions

```{r}

# Prepare data

# Get totals
totals <- prop_data %>% 
  group_by(name,period,change,fao_area,esm,rcp) %>% 
  tally() %>% 
  group_by(name,period,change,fao_area,rcp) %>% 
  summarise(n = mean(n)) %>% 
  filter(rcp == "rcp85") %>% 
  group_by(name,period,fao_area,rcp) %>% 
  summarise(total_stocks = sum(n))


sankey_df <-
  prop_data %>% 
  group_by(name,period,change,fao_area,esm,rcp) %>% 
  tally() %>% 
  group_by(name,period,change,fao_area,rcp) %>% 
  summarise(n = mean(n)) %>% 
  filter(rcp == "rcp85") %>% 
  left_join(totals) %>% 
    mutate(per = (n/total_stocks)*100)



```


# Old code 

```{r}



ggplot() +
  geom_sf(data = sf_fao, aes(), fill ="#3B9AB2" ) +
  geom_sf(data = sf_meow %>% group_by(realm) %>% tally(), aes(fill = realm)) +
  geom_sf(data = sf_land, aes(), fill ="grey" ) +
  ggrepel::geom_label_repel(data = sf_fao_lab,
                            aes(label = f_code,
                                geometry = the_geom),
                            stat = "sf_coordinates",
                            direction = "y",
                            seed = 10,
                            point.padding	 = 1,
                            alpha = 0.8,
                            size = 4)


sf_fao_lab <-
  sf_fao %>% 
  group_by(fao_name,f_code) %>% 
  tally() %>% 
  mutate(fao_name_lab = gsub(",","\n",fao_name))

```




### Highly migratpry speices

Annex I Highly migratory species https://www.un.org/depts/los/convention_agreements/texts/unclos/annex1.htm

```{r un_highly_mig_spp, eval = F}

# CANCELLED CHUNK

# List of SAU species
exploited_spp <- my_path("G","SAU", "exploited_species_list.csv", read = T)


# Families
un_families <- c("Bramidae","Alopiidae","Carcharhinidae","Sphyrnidae","Isurida")

for(i in 1:length(un_families)){
  fam <- un_families[i]
  
  fishbase_df <- fb_tbl("species") %>% 
    mutate(Family = fam) %>% 
    select(Genus, Species, FBname, reffered_as = Family) %>% 
    mutate(scientific_name = paste(Genus,Species)) %>% 
    select(scientific_name,reffered_as)
  
  if(i == 1){
    output <-  fishbase_df
  }else{
    output <- bind_rows(output,fishbase_df)
  }
}


un_species <- tibble(scientific_name = c("Thunnus alalunga","Thunnus thynnus","Thunnus obesus", "Katsuwonus pelamis", "Thunnus albacares", "Thunnus atlanticus","Euthynnus alletteratus","Euthynnus affinis", "Thunnus maccoyii",
                                             "Auxis thazard", "Auxis rochei", 
                                             "Tetrapturus angustirostris", "Tetrapturus belone", "Tetrapturus pfluegeri", "Tetrapturus albidus", "Tetrapturus audax", "Tetrapturus georgei", "Makaira mazara", "Makaira indica","Makaira nigricans",
                                             
                                             "Istiophorus platypterus","Istiophorus albicans",
                                             "Xiphias gladius",
                                             "Scomberesox saurus","Cololabis saira","Cololabis adocetus","Scomberesox saurus scombroides",
                                             "Hexanchus griseus", "Cetorhinus maximus", "Rhincodon typus"),
                         reffered_as = c(
                           rep("Tuna",9),
                           "Frigate mackerel","Frigate mackerel",
                           rep("Marlin",9),
                           "Sail-fish","Sail-fish",
                           "Sword-fish",
                           rep("Saury",4),
                           rep("Shark",3)
                         )) %>% 
  mutate(source = "species")



h_migratory_spp <- bind_rows(output,
                             un_species) %>% 
  group_by(scientific_name,source) %>% 
  tally() %>% 
  mutate(cat = "high_mig")

```
